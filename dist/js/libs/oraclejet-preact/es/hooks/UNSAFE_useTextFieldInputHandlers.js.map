{"version":3,"file":"UNSAFE_useTextFieldInputHandlers.js","sources":["../../../src/hooks/UNSAFE_useTextFieldInputHandlers/useTextFieldInputHandlers.ts"],"sourcesContent":["import { useCallback, useReducer, useRef } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { ValueUpdateDetail } from '../../utils/UNSAFE_valueUpdateDetail';\n\ntype TextFieldInputProps = {\n  value?: string;\n  onInput?: (detail: ValueUpdateDetail<string>) => void;\n  onCommit?: (detail: ValueUpdateDetail<string>) => void;\n  onKeyDown?: (event: KeyboardEvent) => void;\n};\n\nexport function useTextFieldInputHandlers({\n  value,\n  onInput,\n  onCommit,\n  onKeyDown\n}: TextFieldInputProps) {\n  const isComposing = useRef(false);\n  // It is difficult to determine the previous value because, we will get a new value prop when\n  // user types and also when it is updated programmatically. It cannot be differentiated without an\n  // internal state. And we only need to trigger an onCommit for user interacted changes.\n  // So, we maintain two refs here one gets updated on input and another one gets updated on commit.\n  const previousCommitValue = useRef(value);\n  const previousInputValue = useRef(value);\n\n  // When we get a value this is different from previousInputValue, this means the value is updated\n  // programmatically and we need to update the commit value as well.\n  if (value !== previousInputValue.current) {\n    previousCommitValue.current = value;\n  }\n\n  // preactjs/preact #1899 - https://github.com/preactjs/preact/issues/1899\n  // Preact does not force the native input to be controlled, so we need to\n  // trigger a rerender in order to keep it fully controlled.\n  // Force update hack is from https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n  const [, forceUpdate] = useReducer((x) => x + 1, 0);\n\n  // TODO: Currently, this assumes that the input field is a text field\n  // so that the change event can be simulated by capturing blur and enter keydown\n  // event. We might have to make this generic to handle other input types\n  // as well like radio, select, checkbox.\n  const handleChange = useCallback(\n    (event: Event) => {\n      const currentValue = (event.target as HTMLInputElement).value;\n      if (previousCommitValue.current !== currentValue) {\n        onCommit?.({ previousValue: previousCommitValue.current, value: currentValue });\n        previousCommitValue.current = currentValue;\n      }\n    },\n    [onCommit]\n  );\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      onKeyDown?.(event);\n\n      if (event.key === 'Enter') {\n        handleChange(event);\n      }\n    },\n    [handleChange, onKeyDown]\n  );\n  const handleCompositionStart = useCallback(() => {\n    isComposing.current = true;\n  }, []);\n  const handleCompositionEnd = useCallback(() => {\n    isComposing.current = false;\n  }, []);\n  const handleInput = useCallback(\n    (event: Event) => {\n      // In android device we need to update input value even for composition events\n      // See JET-39086 for more details.\n      if (!isComposing.current || getClientHints().platform === 'android') {\n        const newValue = (event.target as HTMLInputElement).value;\n        // update the internal ref to the new value\n        previousInputValue.current = newValue;\n        onInput?.({ previousValue: value, value: newValue });\n\n        // preactjs/preact #1899 - https://github.com/preactjs/preact/issues/1899\n        // Preact does not force the native input to be controlled, so we need to\n        // trigger a rerender in order to keep it fully controlled.\n        // Force a rerender here, so if the value was not pushed back, the input\n        // will be reset to the old value mimicking a controlled input.\n        // One minor issue here is that the cursor position will also be reverted\n        // back to the end due to the forced value update. But this behavior should\n        // be fine as it happens in our oj-input-text as well.\n        forceUpdate(null);\n      }\n    },\n    [value, onInput]\n  );\n\n  return {\n    // With preact/compat, we will not have an onChange event.\n    // \"If you're using preact/compat, most onChange events are internally converted to onInput\n    // to emulate React's behavior. This is one of the tricks we use to ensure maximum\n    // compatibility with the React ecosystem.\"\n    // Since we need the onChange event, we will be simulating this to match the native event\n    // as best as we can. To do this, we will be capturing `blur` event and Enter `keydown` event.\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event\n    onBlur: handleChange,\n    onKeyDown: handleKeyDown,\n    // Since, preact does not support onCompositionStart and onCompositionEnd events\n    // we need to use all lowercase event name to use the native DOM events. Also,\n    // currently we do not have any need for the event object in these two handlers\n    // so ignored the arguments here.\n    oncompositionstart: handleCompositionStart,\n    oncompositionend: handleCompositionEnd,\n    onInput: handleInput\n  };\n}\n"],"names":[],"mappings":";;;;AAWM,SAAU,yBAAyB,CAAC,EACxC,KAAK,EACL,OAAO,EACP,QAAQ,EACR,SAAS,EACW,EAAA;AACpB,IAAA,MAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;;;;;AAKlC,IAAA,MAAM,mBAAmB,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AAC1C,IAAA,MAAM,kBAAkB,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;;;AAIzC,IAAA,IAAI,KAAK,KAAK,kBAAkB,CAAC,OAAO,EAAE;AACxC,QAAA,mBAAmB,CAAC,OAAO,GAAG,KAAK,CAAC;AACrC,KAAA;;;;;AAMD,IAAA,MAAM,GAAG,WAAW,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;;;;;AAMpD,IAAA,MAAM,YAAY,GAAG,WAAW,CAC9B,CAAC,KAAY,KAAI;AACf,QAAA,MAAM,YAAY,GAAI,KAAK,CAAC,MAA2B,CAAC,KAAK,CAAC;AAC9D,QAAA,IAAI,mBAAmB,CAAC,OAAO,KAAK,YAAY,EAAE;AAChD,YAAA,QAAQ,aAAR,QAAQ,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAR,QAAQ,CAAG,EAAE,aAAa,EAAE,mBAAmB,CAAC,OAAO,EAAE,KAAK,EAAE,YAAY,EAAE,CAAC,CAAC;AAChF,YAAA,mBAAmB,CAAC,OAAO,GAAG,YAAY,CAAC;AAC5C,SAAA;AACH,KAAC,EACD,CAAC,QAAQ,CAAC,CACX,CAAC;AACF,IAAA,MAAM,aAAa,GAAG,WAAW,CAC/B,CAAC,KAAoB,KAAI;AACvB,QAAA,SAAS,aAAT,SAAS,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAT,SAAS,CAAG,KAAK,CAAC,CAAC;AAEnB,QAAA,IAAI,KAAK,CAAC,GAAG,KAAK,OAAO,EAAE;YACzB,YAAY,CAAC,KAAK,CAAC,CAAC;AACrB,SAAA;AACH,KAAC,EACD,CAAC,YAAY,EAAE,SAAS,CAAC,CAC1B,CAAC;AACF,IAAA,MAAM,sBAAsB,GAAG,WAAW,CAAC,MAAK;AAC9C,QAAA,WAAW,CAAC,OAAO,GAAG,IAAI,CAAC;KAC5B,EAAE,EAAE,CAAC,CAAC;AACP,IAAA,MAAM,oBAAoB,GAAG,WAAW,CAAC,MAAK;AAC5C,QAAA,WAAW,CAAC,OAAO,GAAG,KAAK,CAAC;KAC7B,EAAE,EAAE,CAAC,CAAC;AACP,IAAA,MAAM,WAAW,GAAG,WAAW,CAC7B,CAAC,KAAY,KAAI;;;QAGf,IAAI,CAAC,WAAW,CAAC,OAAO,IAAI,cAAc,EAAE,CAAC,QAAQ,KAAK,SAAS,EAAE;AACnE,YAAA,MAAM,QAAQ,GAAI,KAAK,CAAC,MAA2B,CAAC,KAAK,CAAC;;AAE1D,YAAA,kBAAkB,CAAC,OAAO,GAAG,QAAQ,CAAC;AACtC,YAAA,OAAO,KAAP,IAAA,IAAA,OAAO,KAAP,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,OAAO,CAAG,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC;;;;;;;;;YAUrD,WAAW,CAAC,IAAI,CAAC,CAAC;AACnB,SAAA;AACH,KAAC,EACD,CAAC,KAAK,EAAE,OAAO,CAAC,CACjB,CAAC;IAEF,OAAO;;;;;;;;AAQL,QAAA,MAAM,EAAE,YAAY;AACpB,QAAA,SAAS,EAAE,aAAa;;;;;AAKxB,QAAA,kBAAkB,EAAE,sBAAsB;AAC1C,QAAA,gBAAgB,EAAE,oBAAoB;AACtC,QAAA,OAAO,EAAE,WAAW;KACrB,CAAC;AACJ;;;;;;;"}