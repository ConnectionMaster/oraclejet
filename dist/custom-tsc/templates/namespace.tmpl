<?js
const { data, props, componentName } = obj;
if (data.events || data.templateSlotProps.length > 0 || props) {
  // if needed, declare a namespace for indirect types to avoid
  // circular references when defining some template slot
  // context alias in the exported element namespace
  const declaredTypesNamespace =
    data.templateSlotProps?.some((templateSlot) => !!templateSlot.slotContextIndirectType)
      ? `_${data.vcomponentName}Types`
      : '';
  if (declaredTypesNamespace) {?>
declare namespace <?js= declaredTypesNamespace ?> {
  <?js
  for (let templateSlot of data.templateSlotProps) {
    if (templateSlot.slotContextIndirectType) {?>
  type <?js= `${templateSlot.slotContextIndirectType}${
    templateSlot.slotDataTypeParamsDeclaration ?? ''}` ?> = <?js= `${templateSlot.slotTypeParamName}${
                                                            templateSlot.slotDataTypeParams ?? ''}` ?>;
<?js
    }
  }?>
}
<?js
  }?>
export namespace <?js= componentName ?> {
  <?js= this.partial('events.tmpl', data.events) ?>
  <?js
  if (props) {
  for (let prop of props) {?>
  // tslint:disable-next-line interface-over-type-literal
  type <?js= prop ?>Changed<?js= this.classTypeParamsDeclaration ?> = JetElementCustomEventStrict<<?js= componentName ?><?js= data.classTypeParams ?>["<?js= prop ?>"]>;
  <?js}
  }?>
  <?js
  for (let templateSlot of data.templateSlotProps) {
    let contextAliasName = templateSlot.slotContextType;
    let renderFuncName = templateSlot.slotRenderType;
    if (
      templateSlot.slotContextTypeParams &&
      templateSlot.slotRenderContextTypeParams
    ) {
      if (templateSlot.slotDataTypeParamsDeclaration) {
        contextAliasName = `${contextAliasName}${templateSlot.slotDataTypeParamsDeclaration}`;
        renderFuncName = `${renderFuncName}${templateSlot.slotDataTypeParamsDeclaration}`;
      }
      // if template slot has an indirect type specified, then it's already been
      // incorporated into slotContextTypeParams, so we only need replace the
      // indirect type instance with one qualified by the declared namespace
      const slotContextDecl =
        templateSlot.slotContextIndirectType
          ? templateSlot.slotContextTypeParams.replace(
              templateSlot.slotContextIndirectType,
              `${declaredTypesNamespace}.${templateSlot.slotContextIndirectType}`
            )
          : templateSlot.slotContextTypeParams;?>
  type <?js= contextAliasName ?> = <?js= slotContextDecl ?>;
  type <?js= renderFuncName ?> = import('ojs/ojvcomponent').TemplateSlot<<?js= templateSlot.slotRenderContextTypeParams ?>>;
  <?js
    }
    // Otherwise TemplateSlot data specified as type literal:
    //    - if not empty, generate context alias FIRST and use context alias to define render function alias
    //    - otherwise, no context alias and define render function alias with empty context
    else {
      const slotProp = data.slots[templateSlot.slotPropName];
      const slotData = slotProp?.['data'];
      if (Object.keys(slotData).length > 0) { ?>
  type <?js= contextAliasName ?> = {
  <?js
        for (let item in slotData) {?>
      <?js= item ?>: <?js= slotData[item]['reftype'] || slotData[item]['type'] ?>;
  <?js 
        }?>
  };
  type <?js= renderFuncName ?> = import('ojs/ojvcomponent').TemplateSlot<<?js= contextAliasName ?>>;
  <?js
      } else { ?>
  type <?js= renderFuncName ?> = import('ojs/ojvcomponent').TemplateSlot<{}>;
  <?js
      }
    }
  }?>
}<?js
}?>
